import random
import pickle
import paramset
import os
import math
import mutation_struct as ms
import subprocess as sb
import BitVector
import re

def Die(str):
    print(str)
    return 1

def ReadFile(file):
    fd = open(file,'rb')
    cont = fd.read()
    fd.close()
    return cont

def WriteFile(file, cont):
    fd = open(file, 'wb')
    if fd.write(cont):
        return 0
    else:
        return 1
    fd.close()

def ListDir(path):
    return os.listdir(path)

def IsEmptyDir(path):
    return ListDir(path) == []

def ClearDir(path):
    for file in os.listdir(path):
        os.remove(os.path.join(path, file))

def SeparateName(fullname):
    if '.' in fullname:
        name, ext = fullname.split('.')
    else:
        name = fullname
        ext = ''
    return name, ext

def CreateAdditionalFiles(num, path='./'):
    filesList = os.listdir(path)
    mutate = ms.Data(random.Random())
    flag = True
    while(num != 0):
        fileToManipulate = random.choice(filesList)
        filePath = os.path.join(paramset.INITDIR, fileToManipulate)
        fileInfo = ReadFile(filePath)
        newFileInfo = mutate.RandomFile(fileInfo)
        name, ext = SeparateName(fileToManipulate)
        name = num + '.' + ext
        fileName = os.path.join(paramset.INITDIR, name)
        if not WriteFile(fileName, newFileInfo):
            flag = False
        num -= 1
    if flag == False:
        return 1
    else:
        return 0

def GetMinFile(src):
    files=os.listdir(src)
    first=False
    minsize=0
    for fl in files:
        tfl=os.path.join(src,fl)
        tsize=os.path.getsize(tfl)
        if first == False:
            minsize=tsize
            first = True
        else:
            if tsize < minsize:
                minsize=tsize
    return minsize

def CheckEnv():
    print("Checking environment")
    if os.getenv('PIN_ROOT') == None:
        print("You need to setup environment variable PIN_ROOT")
        print("Use 'export PIN_ROOT=/path/to/pin/bin")
        return 1
    if open("/proc/sys/kernel/yama/ptrace_scope", 'r').read(1) != 0:
        print("ASLR is not disabled")
        print("Use 'echo 0 > /proc/sys/kernel/yama/ptrace_scope'")
    if open("/proc/sys/kernel/randomize_va_space", 'r').read(1) != 0:
        print("ASLR is not disabled")
        print("Use 'echo 0 > /proc/sys/kernel/randomize_va_space'")

def RunCmd(cmd):
    print("Starting to run '[*]'", cmd)
    process = sb.run(stdout=sb.PIPE, stderr=sb.PIPE)
    print("Run siccessfull")
    return process.returncode

def StrToHex(inpStr):
    inpStr = inpStr[:2]
    if len(inpStr)%2 == 0:
        bytes.fromhex(inpStr)
    else:
        bytes.fromhex('0' + inpStr)
    return inpStr

def FormBitvector(bbDict):
    bbCount = 0
    addrSet = set()
    for adr in bbDict:
        addrSet.add(adr)
        if addrSet not in paramset.BB:
            bbCount += 1
            paramset.BB.append(adr)
    tbv = BitVector.BitVector( size = ( len ( paramset.BB ) ) )
    if bbCount == 0:
        for el in addrSet:
            tbv[paramset.BB.index(el)]=1
        paramset.TEMPTRACE.append(tbv.deep_copy())
    else:
        for bvs in paramset.TEMPTRACE:
            bvs.pad_from_right(bbCount)
        for el in addrSet:
            tbv[paramset.BB.index(el)]=1
        paramset.TEMPTRACE.append(tbv.deep_copy())
    del tbv

def ErrorHandlingBB():
    errorFile = open("errorBB.txt", 'w')
    bvSize = len(paramset.BB)
    bitVect = BitVector.BitVector( size = bvSize )
    bitVect[-1] = 1
    for i in range( bvSize ):
        bitVect >>= 1
        for trace in paramset.TEMPTRACE:
            num = 0
            BT = bitVect & trace
            if BT.count_bits() == 1:
                num += 0
        if num > ((paramset.BBPERC/100)*paramset.TEMPTRACE) \
            and paramset.BB[i] not in paramset.BBWITHOUTERR:
            paramset.BBWITHERR.add(paramset.BB[i])
    for errs in paramset.BBWITHERR:
        errorFile.write("0x%x \n"%(errs,))
    del bitVect
    del BT

def GetBBOffsets():
    ''' This functions load pickle files to prepare BB weights and strings found in binary. The strings are read from a pickle file, generated by IDAPython. This file contains a tuple of two sets (A,B). A= set of all strings found at CMP instructions. B= set of individual bytes, generated from strings of A and CMP.
'''
    tempFull=set()
    tempByte=set()
    for i in range(paramset.LIBNUM):
        pFD=open(paramset.LIBPICKLE[i],"r")
        tBB=pickle.load(pFD)
        for tb in tBB:
            ad=tb+int(paramset.LIBOFFSETS[i],0)
            # we do not consider weights greater than BBMAXWEIGHT and we take log2 of weights as final weight.
            if tBB[tb][0]>paramset.BBMAXWEIGHT:
                paramset.ALLBB[ad]=int(math.log(paramset.BBMAXWEIGHT,2))
            else:
                paramset.ALLBB[ad]=int(math.log((tBB[tb][0]+1),2))
            if i==0:
                paramset.cAPPBB.add(ad)
            paramset.cALLBB.add(ad)
        pFD.close()
        tFD=open(paramset.NAMESPICKLE[i],"r")
        tdata=pickle.load(tFD)
        tempFull.update(tdata[0])# set of full strings from the binary
        tempByte.update(tdata[1])# set of individual bytes from the binary
    if paramset.NOFFBYTES == True:
        tempFull.discard('\xFF\xFF\xFF\xFF')
        tempFull.discard('\xff\xff\xff\xff')
        tempFull.discard('\x00\xFF\xFF\xFF\xFF')
        tempFull.discard('\x00\xff\xff\xff\xff')
        paramset.ALLSTRINGS.append(tempFull.copy())
        paramset.ALLSTRINGS.append(tempByte.copy())


def GetLeaOffset():
    f = open("lea.out", "r")
    leaPattern = re.compile(pattern=r"(\d+) (\w+) \{([0-9,]*)\} \{([0-9,]*)\} \{([0-9,]*)\} \{([0-9,]*)\}",flags=re.I)
    for lines in f:
        match = leaPattern(lines)
        if match:
            res = match.group()
        else:
            continue
    paramset.LEAOFFSETS.add(res)

def FirstRun():
    ''' this function executes the initial test set to determine error handling BBs in the SUT. Such BBs are given zero weights during actual fuzzing.
'''
    print( "[*] Starting dry run now...")
    tempbad=[]
    dfiles=os.listdir(paramset.INITIALD)
    if len(dfiles) <3:
        Die("not sufficient initial files")

    for fl in dfiles:
        tfl=os.path.join(paramset.INITIALD,fl)
        try:
            f=open(tfl, 'r')
            f.close()
        except:
            Die("can not open our own input %s!"%(tfl,))
        (bbs,retc)=execute(tfl)
        if retc < 0:
            Die("looks like we already got a crash!!")
        paramset.GOODBB |= set(bbs.keys())
    print( "[*] Finished good inputs (%d)"%(len(paramset.GOODBB),))
    #now lets run SUT of probably invalid files. For that we need to create them first.
    print ("[*] Starting bad inputs..")
    lp=0
    badbb=set()
    while lp <2:
        try:
                shutil.rmtree(paramset.INPUTD)
        except OSError:
                pass

        os.mkdir(paramset.INPUTD)
        ms.create_files_dry(30)
        dfiles=os.listdir(paramset.INPUTD)
        for fl in dfiles:
            tfl=os.path.join(paramset.INPUTD,fl)
            (bbs,retc)=execute(tfl)
            if retc < 0:
                ms.Die("got a crash")
            tempbad.append(set(bbs.keys()) - paramset.GOODBB)

        tempcomn=set(tempbad[0])
        for di in tempbad:
            tempcomn.intersection_update(set(di))
        badbb.update(tempcomn)
        lp +=1
    paramset.ERRORBBALL=badbb.copy()
    print ("[*] finished common BB. TOtal such BB: %d"%(len(badbb),))
    for ebb in paramset.ERRORBBALL:
        print ("error bb: 0x%x"%(ebb,))
    time.sleep(5)
    if paramset.LIBNUM == 2:
        baseadr=paramset.LIBOFFSETS[1]
        for ele in tempcomn:
            if ele < baseadr:
                paramset.ERRORBBAPP.add(ele)
            else:
                paramset.ERRORBBLIB.add(ele-baseadr)

    del tempbad
    del badbb
    return len(paramset.GOODBB),len(paramset.ERRORBBALL)